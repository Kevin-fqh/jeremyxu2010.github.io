<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>powershell学习备忘 - jeremy的技术点滴</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Jeremy Xu" />
  <meta name="description" content="背景 早就听说微软的powershell非常强大，凭借它可以全命令行操控windows服务器了。最近终于要在工作中用到它了，于是花了几个小时将" />




<meta name="google-site-verification" content="Ol4gI1XKZ2qsa-efwwJvaGeDyXb91RL-pZBv-3uyY-A" />


<meta name="generator" content="Hugo " />


<link rel="canonical" href="https://jeremyxu2010.github.io/2018/02/powershell%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">



<link rel="stylesheet" href="/css/mathjax.css">


<meta property="og:title" content="powershell学习备忘" />
<meta property="og:description" content="背景 早就听说微软的powershell非常强大，凭借它可以全命令行操控windows服务器了。最近终于要在工作中用到它了，于是花了几个小时将" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeremyxu2010.github.io/2018/02/powershell%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/" />
<meta property="article:published_time" content="2018-02-03T23:07:00+08:00" />
<meta property="article:modified_time" content="2018-02-03T23:07:00+08:00" />
<meta itemprop="name" content="powershell学习备忘">
<meta itemprop="description" content="背景 早就听说微软的powershell非常强大，凭借它可以全命令行操控windows服务器了。最近终于要在工作中用到它了，于是花了几个小时将">
<meta itemprop="datePublished" content="2018-02-03T23:07:00&#43;08:00" />
<meta itemprop="dateModified" content="2018-02-03T23:07:00&#43;08:00" />
<meta itemprop="wordCount" content="7648">



<meta itemprop="keywords" content="powershell,windows," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="powershell学习备忘"/>
<meta name="twitter:description" content="背景 早就听说微软的powershell非常强大，凭借它可以全命令行操控windows服务器了。最近终于要在工作中用到它了，于是花了几个小时将"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">jeremy的技术点滴</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/search/">
        <li class="mobile-menu-item">Search</li>
      </a>
  </ul>
</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">jeremy的技术点滴</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/search/">Search</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">powershell学习备忘</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-02-03 </span>
        <div class="post-category">
            
              <a href="/categories/devops/"> devops </a>
            
          </div>
        <span class="more-meta"> 约 7648 字 </span>
        <span class="more-meta"> 预计阅读 16 分钟 </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#powershell">升级powershell版本</a></li>
    <li><a href="#powershell-1">设置允许运行本机powershell脚本</a></li>
    <li><a href="#macoswindowspowershell">设置macOS系统远程连到windows系统的powershell</a></li>
    <li><a href="#windowsvim">给windows安装一个命令行的编辑器vim</a></li>
    <li><a href="#iterm2profile">在iTerm2里创建该连接的profile</a></li>
  </ul>

  <ul>
    <li><a href="#powershell-3">Powershell基础</a>
      <ul>
        <li><a href="#heading-2">基本数学计算</a></li>
        <li><a href="#heading-3">执行外部命令</a></li>
        <li><a href="#cmdlets">命令集cmdlets</a></li>
        <li><a href="#heading-4">别名</a></li>
        <li><a href="#heading-5">管道和重定向</a></li>
        <li><a href="#heading-6">变量</a></li>
        <li><a href="#heading-7">内置变量</a></li>
        <li><a href="#heading-8">环境变量</a></li>
        <li><a href="#heading-9">变量的作用域</a></li>
        <li><a href="#heading-11">指定类型定义变量</a></li>
        <li><a href="#heading-12">命令返回数组</a></li>
        <li><a href="#heading-13">数组</a></li>
        <li><a href="#heading-14">哈希表</a></li>
        <li><a href="#heading-16">管道处理</a></li>
      </ul>
    </li>
    <li><a href="#heading-17">对象、控制流、函数</a>
      <ul>
        <li><a href="#heading-18">对象=属性+方法</a></li>
        <li><a href="#heading-19">对象的属性</a></li>
        <li><a href="#heading-20">对象的方法</a></li>
        <li><a href="#heading-21">静态方法</a></li>
        <li><a href="#heading-22">条件操作符</a></li>
        <li><a href="#if-elseif-else-">IF-ELSEIF-ELSE 条件</a></li>
        <li><a href="#foreach-object-">ForEach-Object 循环</a></li>
        <li><a href="#foreach-">Foreach 循环</a></li>
        <li><a href="#do-while-">Do While 循环</a></li>
        <li><a href="#for-">For 循环</a></li>
        <li><a href="#heading-26">函数</a></li>
      </ul>
    </li>
    <li><a href="#heading-27">其它技巧</a>
      <ul>
        <li><a href="#heading-28">阻止变量解析</a></li>
        <li><a href="#heading-29">给脚本传递参数</a></li>
        <li><a href="#heading-30">在脚本中使用参数名</a></li>
        <li><a href="#heading-31">管道脚本</a></li>
        <li><a href="#heading-32">识别和处理异常</a></li>
        <li><a href="#heading-33">操作字符串</a></li>
        <li><a href="#heading-34">操作正则表达式</a></li>
        <li><a href="#heading-35">操作文件</a></li>
        <li><a href="#heading-36">操作注册表</a></li>
        <li><a href="#ini">操作ini文件</a></li>
        <li><a href="#heading-37">导入模块</a></li>
        <li><a href="#iis">操作IIS</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="heading">背景</h1>
<p>早就听说微软的powershell非常强大，凭借它可以全命令行操控windows服务器了。最近终于要在工作中用到它了，于是花了几个小时将powershell的基础教程看了下，这里将学习过程中的一些要点记录一下。</p>
<h1 id="heading-1">环境准备</h1>
<p>欲善其事，先利其器，先准备一个开发环境。</p>
<p>个人的开发电脑是macOS 11.13.3，为了开发powershell脚本，在本机安装了一个windows 7 sp1的虚拟机。</p>
<h2 id="powershell">升级powershell版本</h2>
<p>win7自带的powershell版本较低，这里将windows 7 sp1里自带的powershell升级到5.1版本。 先安装<a href="http://www.microsoft.com/en-us/download/details.aspx?id=30653">.NET 4.5</a>，然后再安装<a href="https://www.microsoft.com/en-us/download/details.aspx?id=54616">Win7AndW2K8R2-KB3191566-x64.zip</a>。</p>
<h2 id="powershell-1">设置允许运行本机powershell脚本</h2>
<p>以管理员的身份运行PowerShell，在powershell窗口里输出以下命令：</p>
<pre><code>Set-ExecutionPolicy RemoteSigned -Force
</code></pre><h2 id="macoswindowspowershell">设置macOS系统远程连到windows系统的powershell</h2>
<p>本地还是更喜欢iTerm2的终端，windows里带的powershell终端实在是用不惯，于是设置了下通过ssh连接到windows系统的powershell。</p>
<p>从<a href="https://github.com/PowerShell/Win32-OpenSSH/releases/latest/">https://github.com/PowerShell/Win32-OpenSSH/releases/latest/</a>下载OpenSSH for windows的64位二进制包，安装到windows的<code>C:\Program Files\OpenSSH</code>目录。</p>
<p>以管理员的身份运行PowerShell，在powershell窗口里输出以下命令：</p>
<pre><code>cd C:\Program Files\OpenSSH
powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 # 安装sshd服务
netsh advfirewall firewall add rule name=sshd dir=in action=allow protocol=TCP  localport=22 # 允许外部访问ssh端口
net start sshd # 启动sshd服务
Set-Service sshd -StartupType Automatic # 设置sshd服务开机自启动
Set-Service ssh-agent -StartupType Automatic # 设置ssh-agent服务开机自启动
New-Item -type Directory HKLM:\SOFTWARE\OpenSSH
New-Item -itemType String HKLM:\SOFTWARE\OpenSSH\DefaultShell -value &quot;C:\Windows\system32\WindowsPowerShell\v1.0\powershell.exe&quot; # 设置ssh登录的默认shell为powershell
</code></pre><h2 id="windowsvim">给windows安装一个命令行的编辑器vim</h2>
<p>运程操控windows服务器免不了要修改某些配置文件，个人还是比较适应vim，这里在windows里安装好vim。</p>
<p>从<a href="https://vim.sourceforge.io/download.php#pc">https://vim.sourceforge.io/download.php#pc</a>下载vim的windows安装包<a href="ftp://ftp.vim.org/pub/vim/pc/gvim80-586.exe">gvim80.exe</a>，在windows里以默认选项安装一下，正常情况下会安装到<code>C:/Program Files (x86)/Vim</code>目录下。</p>
<p>在windows里以普通身份运行PowerShell，在powershell窗口里输出以下命令：</p>
<pre><code>new-item -path $profile -itemtype file -force
@'
set-alias vim &quot;C:/Program Files (x86)/Vim/vim80/vim.exe&quot;

Function Edit-Profile
{
    vim $profile
}

# To edit Vim settings
Function Edit-Vimrc
{
    vim $HOME\_vimrc
}
'@ &gt; @profile  # 创建并初始化powershell的配置文件

@'
syntax on
colorscheme desert
set backspace=indent,eol,start
'@ &gt; $HOME\_vimrc # 初始化vim的配置文件
</code></pre><h2 id="iterm2profile">在iTerm2里创建该连接的profile</h2>
<p>现在已经可以在iTerm2里通过命令<code>/usr/local/bin/sshpass -p 123456 ssh jeremy@10.211.55.5</code>连接到windows的powershell，其中<code>123456</code>是windows用户<code>jeremy</code>的密码，<code>10.211.55.5</code>是windows的密码。为了连接方便，在iTerm2里创建一个新的profile，登录的命令设置为<code>/usr/local/bin/sshpass -p 123456 ssh jeremy@10.211.55.5</code>，以后以这个profile创建会话就会直接连接到windows的powershell。</p>
<h1 id="powershell-2">powershell学习要点</h1>
<h2 id="powershell-3">Powershell基础</h2>
<h3 id="heading-2">基本数学计算</h3>
<p>基本数学计算比较简单，不单独说了，参见<a href="http://www.pstips.net/powershell-as-a-calculator.html">这里</a></p>
<h3 id="heading-3">执行外部命令</h3>
<p>可直接执行windows命令行命令，甚至可以直接执行cmd命令。如果一个外部命令必须用引号括起来，为了让powershell执行字符串里的命令，可在字符串前加<code>&amp;</code>，这样即可让powershell执行该命令，参见<a href="http://www.pstips.net/powershell-executing-external-commands.html">这里</a></p>
<h3 id="cmdlets">命令集cmdlets</h3>
<p>cmdlets是Powershell的内部命令。</p>
<pre><code>Get-Command -Name Get-Content | Get-Member # 察看一个cmdlet的所有属性、方法、ScriptProperty
Get-Command -CommandType Cmdlet 列出所有cmdlets
Get-Command -CommandType Cmdlet *Service* # 列出名称里包含Service的cmdlets
Get-Help Get-Content #获得某个cmdlet的使用帮助
</code></pre><p>详细参见<a href="http://www.pstips.net/powershell-cmdlets.html">这里</a></p>
<h3 id="heading-4">别名</h3>
<p>cmdlet 的名称由一个动词和一个名词组成，其功能对用户来讲一目了然。但是对于一个经常使用powershell命令的人每天敲那么多命令也很麻烦，于是<code>别名</code>就应运而生了。</p>
<pre><code>Get-Alias -name ls # 查看某一个别名的定义
Get-Alias # 查看所有别名
dir alias: | where {$_.Definition.Startswith(&quot;Remove&quot;)} # 查看所有以Remove打头的cmdlet的命令的别名呢
Set-Alias -Name Edit -Value notepad # 创建别名
del alias:Edit # 删除别名
Export-Alias alias.ps1 # 导出别名
Import-Alias -Force alias.ps1 # 导入别名
</code></pre><p>详细参见<a href="http://www.pstips.net/powershell-alias.html">这里</a></p>
<h3 id="heading-5">管道和重定向</h3>
<p>powershell里支持管道，但要注意不像linux的管道，powershell里管道里输出、输入都是对象，如下：</p>
<pre><code>ls | sort -Descending Name | Format-Table Name,Mode
</code></pre><p>powershell支持重定向，<code>&gt;</code>为覆盖，<code>&gt;&gt;</code>追加，注意可直接将字符串重定向到文件，如下：</p>
<pre><code>&quot;Powershell Routing&quot; &gt; test.txt
&quot;Powershell Routing&quot; &gt;&gt; test.txt
</code></pre><h3 id="heading-6">变量</h3>
<p>变量可以临时保存数据，因此可以把数据保存在变量中，以便进一步操作，powershell 不需要显示地去声明，可以自动创建变量，只须记住变量的前缀为$。</p>
<pre><code>#定义变量
$a=10
$b=4
#计算变量
$result=$a*$b
$msg=&quot;保存文本&quot;

#输出变量
$result
$msg

#交换变量的值
$value1=10
$value2=20
$value1,$value2=$value2,$value1

#查看所有变量
ls variable:

#查询以value打头的变量名
ls variable:value*

#验证变量是否存在
Test-Path variable:value1

#删除变量
del variable:value1

#变量写保护
New-Variable num -Value 100 -Force -Option readonly

#给变量添加描述
new-variable name -Value &quot;me&quot; -Description &quot;This is my name&quot;
ls Variable:name | fl *
</code></pre><p>详细参见<a href="http://www.pstips.net/powershell-define-variable.html">这里</a></p>
<h3 id="heading-7">内置变量</h3>
<p>Powershell 内置变量是指那些一旦打开Powershell就会自动加载的变量。
这些变量一般存放的内容包括</p>
<ol>
<li><strong>用户信息</strong>：例如用户的根目录$HOME</li>
<li><strong>配置信息</strong>：例如powershell控制台的大小，颜色，背景等。</li>
<li><strong>运行时信息</strong>：例如一个函数由谁调用，一个脚本运行的目录等。</li>
</ol>
<p>较常用的内置变量如下：</p>
<pre><code>$?
包含最后一个操作的执行状态。如果最后一个操作成功，则包含 TRUE，失败则包含 FALSE。

$_
包含管道对象中的当前对象。在对管道中的每个对象或所选对象执行操作的命令中，可以使用此变量。

$Args
包含由未声明参数和/或传递给函数、脚本或脚本块的参数值组成的数组。
在创建函数时可以声明参数，方法是使用 param 关键字或在函数名称后添加以圆括号括起、逗号
分隔的参数列表。

$Error
包含错误对象的数组，这些对象表示最近的一些错误。最近的错误是该数组中的第一个错误对象
($Error[0])。

$False
包含 FALSE。可以使用此变量在命令和脚本中表示 FALSE，而不是使用字符串”false”。如果
该字符串转换为非空字符串或非零整数，则可将该字符串解释为 TRUE。

$ForEach
包含 ForEach-Object 循环的枚举数。可以对 $ForEach 变量的值使用枚举数的属性和方法。
此变量仅在运行 For 循环时存在，循环完成即会删除。

$Home
包含用户的主目录的完整路径。此变量等效于 %homedrive%%homepath% 环境变量。

$Host
包含一个对象，该对象表示 Windows PowerShell 的当前主机应用程序。可以使用此变量在命
令中表示当前主机，或者显示或更改主机的属性，如 $Host.version、$Host.CurrentCulture
或 $host.ui.rawui.setbackgroundcolor(“Red”)。

$Input
一个枚举数，它包含传递给函数的输入。$Input 变量区分大小写，只能用于函数和脚本块。（脚
本块本质上是未命名的函数。）在函数的 Process 块中，$Input 变量包含当前位于管道中的对
象。在 Process 块完成后，$Input 的值为 NULL。如果函数没有 Process 块，则 $Input
的值可用于 End 块，它包含函数的所有输入。

$LastExitCode
包含运行的最后一个基于 Windows 的程序的退出代码。

$Matches
$Matches 变量与 -match 和 -not match 运算符一起使用。
将标量输入提交给 -match 或 -notmatch 运算符时，如果检测到匹配，则会返回一个布尔值，
并使用由所有匹配字符串值组成的哈希表填充 $Matches 自动变量。有关 -match 运算符的详细
信息，请参阅 about_comparison_operators。

$MyInvocation
包含一个对象，该对象具有有关当前命令（如脚本、函数或脚本块）的信息。可以使用该对象中的
信息（如脚本的路径和文件名 ($myinvocation.mycommand.path) 或函数的名称
($myinvocation.mycommand.name)）来标识当前命令。对于查找正在运行的脚本的名称，这非常有用。

$NULL
包含 NULL 或空值。可以在命令和脚本中使用此变量表示 NULL，而不是使用字符串”NULL”。
如果该字符串转换为非空字符串或非零整数，则可将该字符串解释为 TRUE。

$PID
包含承载当前 Windows PowerShell 会话的进程的进程标识符 (PID)。

$Profile
包含当前用户和当前主机应用程序的 Windows PowerShell 配置文件的完整路径。可以在命令
中使用此变量表示配置文件。例如，可以在命令中使用此变量确定是否已创建某个配置文件：
test-path $profile
也可以在命令中使用此变量创建配置文件：
new-item -type file -path $pshome -force

$PsHome
包含 Windows PowerShell 的安装目录的完整路径（通常为
%windir%System32WindowsPowerShellv1.0）。可以在 Windows PowerShell 文件
的路径中使用此变量。例如，下面的命令在概念性帮助主题中搜索”variable”一词：
select-string -pattern variable -path $pshome*.txt

$PSScriptRoot
包含要从中执行脚本模块的目录。
通过此变量，脚本可以使用模块路径来访问其他资源。

$PsVersionTable
包含一个只读哈希表，该哈希表显示有关在当前会话中运行的 Windows PowerShell 版本的详
细信息。
该表包括下列项：
CLRVersion： 公共语言运行时 (CLR) 的版本
BuildVersion： 当前版本的内部版本号
PSVersion： Windows PowerShell 版本号
WSManStackVersion： WS-Management 堆栈的版本号
PSCompatibleVersions： 与当前版本兼容的 Windows PowerShell 版本
SerializationVersion ：序列化方法的版本
PSRemotingProtocolVersion：Windows PowerShell 远程管理协议的版本

$Pwd
包含一个路径对象，该对象表示当前目录的完整路径。

$ShellID
包含当前 shell 的标识符。

$True
包含 TRUE。可以在命令和脚本中使用此变量表示 TRUE。
</code></pre><p>详细参见<a href="http://www.pstips.net/powershell-automatic-variables.html">这里</a></p>
<h3 id="heading-8">环境变量</h3>
<p>传统的控制台一般没有象Powershell这么高级的变量系统。它们都是依赖于机器本身的环境变量，进行操作 。环境变量对于powershell显得很重要，因为它涵盖了许多操作系统的细节信息。</p>
<pre><code>$env:windir # windows目录
$env:ProgramFiles # 默认程序安装目录
$env:COMPUTERNAME # 主机名
$env:OS # 操作系统名称
ls env: # 查找环境变量
$env:TestVar1=&quot;This is my environment variable&quot; # 创建新的环境变量
ls env:Test* # 模糊查找环境变量
$env:TestVar1=&quot;This is my new environment variable&quot; # 更新环境变量
del env:TestVar1 # 删除环境变量
$env:Path+=&quot;;C:\PowerShell\myscript&quot; # 更改Path环境变量
[environment]::SetEnvironmentvariable(&quot;Path&quot;, &quot;;c:\powershell\myscript&quot;, &quot;User&quot;) # 修改系统的环境变量
[environment]::GetEnvironmentvariable(&quot;Path&quot;, &quot;User&quot;) # 从系统读取环境变量
</code></pre><p>详细参见<a href="http://www.pstips.net/powershell-environment-variables.html">这里</a></p>
<h3 id="heading-9">变量的作用域</h3>
<p>Powershell所有的变量都有一个决定变量是否可用的作用域。Powershell支持四个作用域：全局、当前、私有和脚本。有了这些作用域就可以限制变量的可见性了，尤其是在函数和脚本中。</p>
<h4 id="heading-10">设置单个变量的作用域</h4>
<p><strong>$global</strong>
全局变量，在所有的作用域中有效，如果你在脚本或者函数中设置了全局变量，即使脚本和函数都运行结束，这个变量也任然有效。</p>
<p><strong>$script</strong>
脚本变量，只会在脚本内部有效，包括脚本中的函数，一旦脚本运行结束，这个变量就会被回收。</p>
<p><strong>$private</strong>
私有变量，只会在当前作用域有效，不能贯穿到其他作用域。</p>
<p><strong>$local</strong>
默认变量，可以省略修饰符，在当前作用域有效，其它作用域只对它有只读权限。</p>
<p>详细参见<a href="http://www.pstips.net/powershell-scope-of-variables.html">这里</a></p>
<h3 id="heading-11">指定类型定义变量</h3>
<pre><code># 解析日期
[DateTime]$date=&quot;2012-12-20 12:45:00&quot;
$date

# 解析XML
[ XML ]$xml=(Get-Content .LogoTestConfig.xml)
$xml.LogoTest

# 解析IP地址
[Net.IPAddress]$ip='10.3.129.71'
</code></pre><p>详细参见<a href="http://www.pstips.net/powershell-variable-strongly-typing.html">这里</a></p>
<h3 id="heading-12">命令返回数组</h3>
<p>当我们把一个外部命令的执行结果保存到一个变量中时，Powershell会把文本按每一行作为元素存为数组。</p>
<pre><code>#ipconfig的输出结果是一个数组
$ip=ipconfig
$ip -is [array]
</code></pre><p>真正的Powershell命令返回的数组元素可不止一个字符串，它是一个内容丰富的对象。</p>
<pre><code>#ls的输出结果仍然是一个数组
$result=ls
$result -is [array]

#数组里的元素是一个对象
$result[0].gettype().fullname
$result[0] | fl *
</code></pre><h3 id="heading-13">数组</h3>
<pre><code>#使用逗号创建数组
$nums=2,0,1,2
#创建连续数字的数组
$nums=1..5
#创建空数组
$a=@()
#判断是否是一个数组
$a -is [array]
#得到数组里元素的个数
$a.Count
#访问数组
$books=&quot;元素1&quot;,&quot;元素2&quot;,&quot;元素3&quot;
$books[0]
$books[($books.Count-1)]
#从数组中选择多个元素
$books[0,2]
#将数组逆序输出
$books[($books.Count)..0]
#给数组添加元素
$books+=&quot;元素4&quot;
#删除第3个元素
$books=$books[0..1]+$books[3]
#复制数组
$booksNew=$books.Clone()
#创建强类型数组
[int[]] $nums=@()
</code></pre><h3 id="heading-14">哈希表</h3>
<pre><code>#创建哈希表
$stu=@{ Name = &quot;小明&quot;;Age=&quot;12&quot;;sex=&quot;男&quot; }
#访问哈希键值
$stu[&quot;Name&quot;]
#得到哈希表里元素的个数
$stu.Count
#得到所有哈希键
$stu.Keys
#得到所有哈希值
$stu.Values
#插入新的键值
$stu.Name=&quot;令狐冲&quot;
#更新哈希表值
$stu.Name=&quot;赵强&quot;
#删除哈希表值
$stu.Remove(&quot;Name&quot;)
#在哈希表中存储数组
$stu=@{ Name = &quot;小明&quot;;Age=&quot;12&quot;;sex=&quot;男&quot;;Books=&quot;三国演义&quot;,&quot;围城&quot;,&quot;哈姆雷特&quot; }
</code></pre><h4 id="heading-15">使用哈希表格式化输出</h4>
<pre><code>#控制输出哪些列
Dir | Format-Table FullName,Mode

#自定义输出列的格式
$column1 = @{expression=&quot;Name&quot;; width=30;label=&quot;filename&quot;; alignment=&quot;left&quot;}
$column2 = @{expression=&quot;LastWriteTime&quot;; width=40;label=&quot;last modification&quot;; alignment=&quot;right&quot;}
ls | Format-Table $column1, $column2
</code></pre><h3 id="heading-16">管道处理</h3>
<p>常用的对管道结果进一步处理的命令有：</p>
<pre><code>Compare-Object: 比较两组对象。
ConvertTo-Html: 将 Microsoft .NET Framework 对象转换为可在 Web 浏览器中显示的 HTML。
Export-Clixml: 创建对象的基于 XML 的表示形式并将其存储在文件中。
Export-Csv: 将 Microsoft .NET Framework 对象转换为一系列以逗号分隔的、长度可变的 (CSV) 字符串，并将这些字符串保存到一个 CSV 文件中。
ForEach-Object: 针对每一组输入对象执行操作。
Format-List: 将输出的格式设置为属性列表，其中每个属性均各占一行显示。
Format-Table: 将输出的格式设置为表。
Format-Wide: 将对象的格式设置为只能显示每个对象的一个属性的宽表。
Get-Unique: 从排序列表返回唯一项目。
Group-Object: 指定的属性包含相同值的组对象。
Import-Clixml: 导入 CLIXML 文件，并在 Windows PowerShell 中创建相应的对象。
Measure-Object: 计算对象的数字属性以及字符串对象（如文本文件）中的字符数、单词数和行数。
more: 对结果分屏显示。
Out-File: 将输出发送到文件。
Out-Null: 删除输出，不将其发送到控制台。
Out-Printer: 将输出发送到打印机。
Out-String: 将对象作为一列字符串发送到主机。
Select-Object: 选择一个对象或一组对象的指定属性。它还可以从对象的数组中选择唯一对象，也可以从对象数组的开头或末尾选择指定个数的对象。
Sort-Object: 按属性值对象进行排序。
Tee-Object: 将命令输出保存在文件或变量中，并将其显示在控制台中。
Where-Object: 创建控制哪些对象沿着命令管道传递的筛选器。
</code></pre><p>其中:</p>
<p>Format的管道处理用法参见<a href="http://www.pstips.net/powershell-converting-objects-into-text.html">这里</a></p>
<p>排序和分组的管道处理用法参见<a href="http://www.pstips.net/powershell-sort-and-group-pipeline-results.html">这里</a></p>
<p><code>Select-Object</code>、<code>Where-Object</code>、<code>ForEach-Object</code>用法参见<a href="http://www.pstips.net/powershell-filtering-pipeline-results.html">这里</a></p>
<p>导出的管道处理用法参见<a href="http://www.pstips.net/powershell%E5%AF%BC%E5%87%BA%E7%AE%A1%E9%81%93%E7%BB%93%E6%9E%9C.html">这里</a></p>
<h2 id="heading-17">对象、控制流、函数</h2>
<h3 id="heading-18">对象=属性+方法</h3>
<p>Powershell中的对象和现实生活很相似。例如要在现实生活中描述一把小刀。我们可能会分两方面描述它。
<strong>属性</strong>：一把小刀拥有一些特殊的属性，比如它的颜色、制造商、大小、刀片数。这个对象是红色的，重55克，有3个刀片，ABC公司生产的。因此属性描述了一个对象是什么。
<strong>方法</strong>：可以使用这个对象做什么，比如切东西、当螺丝钉用、开啤酒盖。一个对象能干什么就属于这个对象的方法。</p>
<pre><code>#创建对象
$pocketknife=New-Object object
#增加属性
Add-Member -InputObject $pocketknife -Name Color -Value &quot;Red&quot;
-MemberType NoteProperty
$pocketknife | Add-Member NoteProperty Blades 3
#增加方法
Add-Member -memberType ScriptMethod -In $pocketknife -name cut -Value { &quot;I'm whittling now&quot; }
$pocketknife | Add-Member ScriptMethod corkscrew { &quot;Pop! Cheers!&quot; }
</code></pre><h3 id="heading-19">对象的属性</h3>
<pre><code>#直接使用点访问对象的属性
$Host.Version
#查看Version的具体类型
$Host.Version.GetType().FullName
#查看对象所有属性
$Host | Get-Member -memberType property
</code></pre><h3 id="heading-20">对象的方法</h3>
<pre><code>#查看对象所有的方法
$Host | Get-Member -MemberType Method
#调用方法
$Host.GetType()
$Host.UI.WriteDebugLine(&quot;Hello 2012 !&quot;)
#列出重载方法
$method=$Host.UI | Get-Member WriteLine
$method.Definition.Replace(&quot;),&quot;,&quot;)`n&quot;)
</code></pre><h3 id="heading-21">静态方法</h3>
<pre><code>#查看某类型的静态方法
[System.DateTime] | Get-Member -static -memberType Method
#调用静态方法
[System.DateTime]::Parse(&quot;2012-10-13 23:42:55&quot;)
#根据IP反查域名
[system.Net.Dns]::GetHostByAddress('8.8.8.8').HostName
#查询某类型下的所有枚举
[System.Enum]::GetNames([System.ConsoleColor])
</code></pre><h3 id="heading-22">条件操作符</h3>
<h4 id="heading-23">比较运算符</h4>
<p><strong>-eq</strong> ：等于
<strong>-ne</strong> ：不等于
<strong>-gt</strong> ：大于
<strong>-ge</strong> ：大于等于
<strong>-lt</strong> ：小于
<strong>-le</strong> ：小于等于
<strong>-contains</strong> ：包含
<strong>-notcontains</strong> :不包含</p>
<h4 id="heading-24">求反</h4>
<p>求反运算符为-not 但是像高级语言一样<code>!</code>也支持求反</p>
<h4 id="heading-25">布尔运算</h4>
<p><strong>-and</strong> ：和
<strong>-or</strong> ：或
<strong>-xor</strong> ：异或
<strong>-not</strong> ：逆</p>
<pre><code>PS C:Powershell&gt; (3,4,5 ) -contains 2
False
PS C:Powershell&gt; (3,4,5 ) -contains 5
True
PS C:Powershell&gt; (3,4,5 ) -notcontains 6
True
PS C:Powershell&gt; 2 -eq 10
False
PS C:Powershell&gt; &quot;A&quot; -eq &quot;a&quot;
True
PS C:Powershell&gt; &quot;A&quot; -ieq &quot;a&quot;
True
PS C:Powershell&gt; &quot;A&quot; -ceq &quot;a&quot;
False
PS C:Powershell&gt; 1gb -lt 1gb+1
True
PS C:Powershell&gt; 1gb -lt 1gb-1
False
PS C:Powershell&gt; $a= 2 -eq 3
PS C:Powershell&gt; $a
False
PS C:Powershell&gt; -not $a
True
PS C:Powershell&gt; !($a)
True
PS C:Powershell&gt; $true -and $true
True
PS C:Powershell&gt; $true -and $false
False
PS C:Powershell&gt; $true -or $true
True
PS C:Powershell&gt; $true -or $false
True
PS C:Powershell&gt; $true -xor $false
True
PS C:Powershell&gt; $true -xor $true
False
PS C:Powershell&gt;  -not  $true
False
#过滤数组中的元素
PS C:Powershell&gt; 1,2,3,4,3,2,1 -eq 3
3
3
PS C:Powershell&gt; 1,2,3,4,3,2,1 -ne 3
1
2
4
2
1
#验证一个数组是否存在特定元素
PS C:Powershell&gt; 1,9,4,5 -contains 9
True
PS C:Powershell&gt; 1,9,4,5 -contains 10
False
PS C:Powershell&gt; 1,9,4,5 -notcontains 10
True
</code></pre><h3 id="if-elseif-else-">IF-ELSEIF-ELSE 条件</h3>
<p>Where-Object 进行条件判断很方便，如果在判断后执行很多代码可以使用IF-ELSEIF-ELSE语句。语句模板：</p>
<pre><code>If（条件满足）{
如果条件满足就执行代码
}
Else
{
如果条件不满足
}
</code></pre><h3 id="foreach-object-">ForEach-Object 循环</h3>
<pre><code>#杀掉名字里包含rar的进程
Get-Process | Where-Object {$_.ProcessName -like '*rar*'} | ForEach-Object {$_.Kill()}
</code></pre><h3 id="foreach-">Foreach 循环</h3>
<pre><code>$array=7..10
foreach ($n in $array)
{
    $n*$n
}
</code></pre><h3 id="do-while-">Do While 循环</h3>
<pre><code>do { $n=Read-Host } while( $n -ne 0)
#单独使用While
$n=5
while($n -gt 0)
{
    $n
    $n=$n-1
}
#终止当前循环
$n=1
while($n -lt 6)
{
    if($n -eq 4)
    {
        $n=$n+1
        continue
 
    }
    else
    {
        $n
    }
    $n=$n+1
}
#跳出循环
$n=1
while($n -lt 6)
{
    if($n -eq 4)
    {
        break
    }
    $n
    $n++
}
</code></pre><h3 id="for-">For 循环</h3>
<pre><code>$sum=0
for($i=1;$i -le 100;$i++)
{
    $sum+=$i
}
$sum
</code></pre><h3 id="heading-26">函数</h3>
<pre><code>#定义函数模板
Function FuncName （args[]）
{
      code;
}
#删除函数
del Function:myPing
#万能参数
function sayHello
{
    if($args.Count -eq 0)
    {
        &quot;No argument!&quot;
    }
    else
    {
        $args | foreach {&quot;Hello,$($_)&quot;}
    }
}

#设置参数名称
function StringContact($str1,$str2)
{
    return $str1+$str2
}
 

StringContact -str1 word -str2 press

#给参数定义默认值
function stringContact($str1=&quot;moss&quot;,$str2=&quot;fly&quot;)
{
    return $str1+$str2
}

stringContact

# 列出所有函数
dir function: | ft -AutoSize

#函数过滤器管道
Filter MarkEXE
{
    # 记录当前控制台的背景色
    $oldcolor = $host.ui.rawui.ForegroundColor
    # 当前的管道元素保存在 $_ 变量中
    # 如果后缀名为 &quot;.exe&quot;,
    # 改变背景色为红色:
    If ($_.name.toLower().endsWith(&quot;.exe&quot;))
    {
        $host.ui.Rawui.ForegroundColor = &quot;red&quot;
    }
    Else
    {
        # 否则使用之前的背景色
        $host.ui.Rawui.ForegroundColor = $oldcolor
    }
    # 输出当前元素
    $_
    # 最后恢复控制台颜色:
    $host.ui.Rawui.ForegroundColor = $oldcolor
}

Function MarkEXE
{
    begin
    {
        # 记录控制台的背景色
        $oldcolor = $host.ui.rawui.ForegroundColor
    }
    process
    {
        # 当前管道的元素 $_
        # 如果后缀名为 &quot;.exe&quot;,
        # 改变背景色为红色:
        If ($_.name.toLower().endsWith(&quot;.exe&quot;))
        {
            $host.ui.Rawui.ForegroundColor = &quot;red&quot;
        }
        Else
        {
            # 否则, 使用正常的背景色:
            $host.ui.Rawui.ForegroundColor = $oldcolor
         }
        # 输出当前的背景色
        $_
      }
    end
    {
        # 最后,恢复控制台的背景色:
        $host.ui.Rawui.ForegroundColor = $oldcolor
     }
}
</code></pre><h2 id="heading-27">其它技巧</h2>
<h3 id="heading-28">阻止变量解析</h3>
<pre><code>PS E:&gt; @'
&gt;&gt; Get-Date
&gt;&gt; $Env:CommonProgramFiles
&gt;&gt; #Script End
&gt;&gt; &quot;files count&quot;
&gt;&gt; (ls).Count
&gt;&gt; #Script Really End
&gt;&gt;
&gt;&gt; '@ &gt; myscript.ps1
&gt;&gt;
</code></pre><h3 id="heading-29">给脚本传递参数</h3>
<pre><code>@'
For($i=0;$i -lt $args.Count; $i++)
{
    Write-Host &quot;parameter $i : $($args[$i])&quot;
}
'@ &gt;  MyScript.ps1

PS E:&gt; .\MyScript.ps1 www moss fly com
parameter 0 : www
parameter 1 : moss
parameter 2 : fly
parameter 3 : com
</code></pre><h3 id="heading-30">在脚本中使用参数名</h3>
<pre><code>@'
param($Directory,$FileName)
 
&quot;Directory= $Directory&quot;
&quot;FileName=$FileName&quot;
'@ &gt;  MyScript.ps1

PS E:&gt; .\MyScript.ps1 -Directory $env:windir -FileName config.xml
Directory= C:\windows
FileName=config.xml
</code></pre><h3 id="heading-31">管道脚本</h3>
<pre><code>@'
begin
{
    Write-Host &quot;管道脚本环境初始化&quot;
}
process
{
    $ele=$_
    if($_.Extension -ne &quot;&quot;)
    {
        switch($_.Extension.tolower())
        {
            &quot;.ps1&quot; {&quot;脚本文件：&quot;+ $ele.name}
            &quot;.txt&quot; {&quot;文本文件：&quot;+ $ele.Name}
            &quot;.gz&quot;  {&quot;压缩文件：&quot;+ $ele.Name}
        }
    }
}
end
{
    Write-Host &quot;管道脚本环境恢复&quot;
}
'@ &gt; pipeline.ps1

ls | .\pipeline.ps1
</code></pre><h3 id="heading-32">识别和处理异常</h3>
<pre><code># 错误不抛出，脚本也会继续执行
$ErrorActionPreference='SilentlyContinue'
Remove-Item &quot;文件不存在&quot; | Out-Null
If (!$?)
{
&quot;发生异常，异常信息为$($error[0])&quot;;
break
}
&quot;删除文件成功!&quot;
</code></pre><h3 id="heading-33">操作字符串</h3>
<p>详细参见<a href="http://www.pstips.net/string-operators.html">这里</a></p>
<h3 id="heading-34">操作正则表达式</h3>
<p>详细参见<a href="http://www.pstips.net/regex-describing-patterns.html">这里</a></p>
<h3 id="heading-35">操作文件</h3>
<p>详细参见<a href="http://www.pstips.net/the-file-system.html">这里</a></p>
<h3 id="heading-36">操作注册表</h3>
<p>详细参见<a href="http://www.pstips.net/the-registry.html">这里</a></p>
<h3 id="ini">操作ini文件</h3>
<p>详细参见<a href="https://github.com/lipkau/PsIni">这里</a></p>
<h3 id="heading-37">导入模块</h3>
<p>详细参见<a href="https://guhuajun.wordpress.com/2009/06/14/windows-powershell-v2-%E4%BB%8B%E7%BB%8D-8-%E6%A8%A1%E5%9D%97/">这里</a></p>
<h3 id="iis">操作IIS</h3>
<p>Win2008 *,角色&ndash;&gt;添加角色&mdash;&gt;功能工具下面的'IIS管理脚本和工具&rsquo;
Win7 在卸载程序中，点击'打开或关闭Windows功能&rsquo;&mdash;&gt;'Internet信息服务&rsquo;&mdash;&gt;'Web管理工具&rsquo;&mdash;&gt;'IIS管理脚本和工具&rsquo;</p>
<p>主要用到的方法有</p>
<pre><code>#创建站点
$site = New-Item IIS:\Sites\$siteName -bindings $bindings -physicalPath $physicalPath -ErrorAction Stop
...
#创建应用程序池
$apool = New-Item IIS:\AppPools\$appPool
Set-ItemProperty IIS:\AppPools\$appPool managedRuntimeVersion $runtimeVersion
#1:Classic or 0:Integrated
Set-ItemProperty IIS:\AppPools\$appPool managedPipelineMode $pipelineMode
...
#关联程序池
Set-ItemProperty IIS:\Sites\$siteName -name applicationPool -value $apool
...    
#创建应用程序
$app = New-Item IIS:\Sites\$siteName\$appName  -physicalPath $appPhysPath -type Application
$site = Get-Item &quot;IIS:\Sites\$siteName&quot;
Set-ItemProperty IIS:\Sites\$siteName\$appName -name applicationPool -value $site.applicationPool
...
#获取站点
$site = Get-Item &quot;IIS:\Sites\$siteName&quot; -ErrorAction Stop
...
#获取应用程序
$app = Get-Item &quot;IIS:\Sites\$siteName\$appName&quot; -ErrorAction Stop
...
</code></pre><p>详细参见<a href="https://technet.microsoft.com/en-us/library/hh867899(v=wps.630).aspx">这里</a></p>
<h1 id="heading-38">参考</h1>
<ol>
<li><a href="https://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx">https://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx</a></li>
<li><a href="https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH">https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH</a></li>
<li><a href="http://www.wowotech.net/soft/vim_in_powershell.html">http://www.wowotech.net/soft/vim_in_powershell.html</a></li>
<li><a href="http://www.pstips.net/powershell-online-tutorials/">http://www.pstips.net/powershell-online-tutorials/</a></li>
</ol>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Jeremy Xu</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2018-02-03</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content">&copy; Copyright 2020 Jeremy Xu</span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/wechat-qr-code.png">
        <span>微信打赏</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/alipay-qr-code.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/powershell/">powershell</a>
          
          <a href="/tags/windows/">windows</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/2018/02/centos6%E4%B8%8Brpm%E6%89%93%E5%8C%85%E5%AE%9E%E6%88%98/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">CentOS6下rpm打包实战</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/2018/01/centos7%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4/">
            <span class="next-text nav-default">CentOS7部署k8s集群</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        


<div id="utter-container"></div>
<script src="https://utteranc.es/client.js" repo='jeremyxu2010/blog_comment'
  issue-term="title" theme='github-light' crossorigin="anonymous" async>
  </script>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jeremyxu2010@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://plus.google.com/u/0/103057094241630654183" class="iconfont icon-google" title="google"></a>
      <a href="https://github.com/jeremyxu2010" class="iconfont icon-github" title="github"></a>
  <a href="https://jeremyxu2010.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">&copy; Copyright 2019 Jeremy Xu</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\[\[','\]\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
           extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
  });
  
  MathJax.Hub.Queue(function() {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for(i = 0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
  </script>








<script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.0/fuse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js"></script>
<script src="https://jeremyxu2010.github.io/js/search.js"></script>


</body>
</html>
